# CodeSpitz71

## 2강

GOF의 디자인 패턴 분류
1. 생성패턴
2. 구조패턴
3. 행동패턴
-> 이미 객체지향설계에 익숙한 사람들을 위한 것

객체지향설계를 학습할 수 있는 분류
1. 다형성
    대체 가능성(자식 자리에 부모가 올 수 있다.), 내적 동질성
2. 캡슐화
    어떤 복잡한 기능을 외부에 노출하지 않고 표현하고 싶은 기능만 노출 함.
3. 객체 간 관계
4. 
5. 

### Algorithm Pattern
제어문을 해결하는 패턴!

기존 제어문 기반의 알고리즘이 갖는 문제
-> 수정하면 전체가 컴파일 됨.

정의 시점과 생성 시점은 상대적이지만 컴파일은 정의 시점이라는 말.

격리 이론을 쓰는 이유는 안고치려고!
제어문으로 만들면 다 위배됨.
한번 고치면 다 고쳐야 함.

알고리즘이 변화하는 이유는
1. 비지니스 변화
2. 연관 라이브러리 변화
3. 호스트측 변화
-> 통제불가능한 요소(요구사항이 바뀌는 건 당연한거)

중복은 확정 버그다.

### 알고리즘 분화 시 객체지향에서 선택할 수 있는 두 가지 방법

1. 상속 위임
    내부계약관계로 추상층에서 공통요소를 해결하고 상태를 공유할 수 있음.
    상태를 공유할 수 있다는 것이 중요!

2. 소유 위임
    외부계약관계로 각각이 독립적인 문제를 해결하며 메세지를 주고 받는 것으로 문제를 해결함.
    프로토콜(메세지)로 문제를 해결함.
    GoF DP의 방향성임!

### TEMPLATE METHOD PATTERN
상속위임을 통해 정의시점 공통부분, 실행시점 위임부분으로 나누어 부모 객체를 template화 시켜준다.
상속위임을 지향하고 있는 독특한 패턴.

### RUNTIME DELEGATION
실행시점 위임을 통해 문제를 해결함.

### STRATEGE PATTERN
소유위임을 통해 실행시점 외부계약을 만들어 해결.

### RUNTIME DELEGATION
실행시점 위임을 통해 문제를 해결함.

각 경우별 변화는 개별 함수만 변경하면 됨.

TEMPLATE METHOD PATTERN은 template이 정의될 수 있을 경유에만 사용할 수 있다.

간이 인터페이스는 형으로 감싸서 마킹을 하기 때문에 마커 인터페이스라고 부른다.

es6는 함수의 기본값이 생김. 객체 리터럴의 순서를 보장함.

상태에 대한 분기는 사라지지 않는다. => 그 분기가 필요해서 태어났기 때문.


### 생성 레시피 캡슐화


컴포넌트 패턴의 대표주자 => MVC 패턴